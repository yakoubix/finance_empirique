---
title: "Gestion de Portefeuille"
subtitle: "TP-2: Droite de Marchés des Capitaux"
author: Patrick Hénaff
date: "Février-Mars 2021"
output: 
  pdf_document:
    keep_tex: true
    fig_caption: yes
    latex_engine: pdflatex
geometry: margin=1in

header-includes:
  - \usepackage[utf8]{inputenc}

bibliography: ../library.bib
csl: ../apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r load-libraries, include=FALSE, echo=TRUE}
library(quantmod)
library(xts)
library(hornpa)
library(lubridate)
library(xtable)
library(PerformanceAnalytics)
library(TTR)
library(SuppDists)
library(lubridate)
library(roll)
library(Hmisc)
library(nFactors)
library(kableExtra)

get.src.folder <- function() {
  path.expand("../GP/src")
}

get.data.folder <- function() {
  path.expand("../GP/data")
}

source(file.path(get.src.folder(), 'utils.R'))
source(file.path(get.src.folder(), 'FileUtils.R'))
```

# Données

## Séries de rendement quotidien pour 11 valeurs:

```{r, eval=TRUE, echo=TRUE, warning=FALSE}
daily.ret.file <- file.path(get.data.folder(), "daily.ret.rda")
load(daily.ret.file)
kable(table.Stats(daily.ret), "latex", booktabs=T) %>% kable_styling(latex_options="scale_down")
```

## Rendement annuel moyen:

```{r, echo=TRUE}
kable(252*100*colMeans(daily.ret), "latex", booktabs=T, digits=1, col.names=c("Rendement (%)"), 
      caption="Rendement annuel moyen")
```

## Matrice de corrélation des rendements:

```{r, echo=TRUE}
correl <- cor(daily.ret)
correl[lower.tri(correl)] <- NA
options(knitr.kable.NA = '')
kable(correl, "latex", booktabs=T, digits=2, caption="Corrélation des rendements quotidiens") %>%
kable_styling(latex_options="scale_down")
```

# Droite de Marché des Capitaux (Capital Market Line)

+ A partir des calculs présentés en cours, mettre en oeuvre une méthode numérique
  pour déterminer le portefeuille tangent quand les poids des actifs risqués sont contraints à être positifs: $w_i >= 0$.

+ Même calcul en ajoutant des contraintes supplémentaires qui vous semblent pertinentes 
(ex: pas plus de 20\% de l'actif risqué alloué à un seul titre, etc.)

```{r, tangent-2}
# Risk-free rate
r.f = 0.03
cex.val <- 1.5
# by formula
mu <- colMeans(daily.ret)*252
sigma <- cov(daily.ret)*252
rho <- cor(daily.ret)
sig2 <- sigma %*% t(sigma) * rho
w.nom <- solve(sig2, mu-r.f)
w.den <- sum(w.nom)
w.t <- w.nom/sum(w.nom)

mu.t <- as.vector(t(mu) %*% w.t)
sigma.t <- sqrt(t(w.t) %*% sig2 %*% w.t)
```

```{r, echo=FALSE}
alpha <- seq(from=-0.4, to=1.4, by=0.1)

w_1 <- matrix(rep(1/11, 11),11,1)
w_2 <- 1 - w_1
w <- w_1 %*% alpha + w_2 %*% (1-alpha)

mu.frontier <- as.vector(t(mu) %*% w)
sigma.frontier <- sqrt(diag(t(w) %*% sig2 %*% w))
```

```{r}
plot(sigma.frontier, mu.frontier, type="b", pch=1, cex = .7,
     ylim=c(0, max(mu.frontier)), xlim=c(0, max(sigma.frontier)),
     xlab=expression(sigma), ylab=expression(mu), cex.lab = cex.val, bty='n')
text(x=0.0, y=r.f, labels=expression(r[f]), pos=2, offset=0)
text(x=sigma, y=mu, labels=assets, pos=4, cex = 1)
text(x=sigma.t, y=mu.t, labels="Tangency", pos=2, offset=2)
abline(a=r.f, b=(mu.t-r.f)/sigma.t, col='red', lty=2)
```
```{r, echo=FALSE}
r.f = 0.03

mu.star.v  <- seq(from=mu.free, to=0.35, length.out=30)
mu <- colMeans(daily.ret)*252
sigma <- cov(daily.ret)*252
tickers <- c("AAPL", "AMZN", "MSFT", "F", "SPY", "QQQ", "XOM", "MMM", "HD", "PG", "KO")


n <- length(mu)


optim.with.rf <- function(mu.star) {
 A.sum <- matrix(mu-r.f, ncol=1)
A.mat <- cbind(A.sum,
               rep(1, n),
               diag(n))
b <- c( mu.star,1, rep(0, n))
solve.QP(2*sigma, rep(0,n), A.mat, b, meq=2)
}



sol.with.rf <- NULL
for(mu.star in mu.star.v) {
  qp <- optim.with.rf(mu.star)

  sharpe <- (mu.star - mu.free) / sqrt(qp$value)
  tmp <- matrix(c(mu.star, sqrt(qp$value), sharpe, qp$solution), nrow=1)

if(is.null(sol.with.rf)) {
  sol.with.rf <- tmp  
} else {
  sol.with.rf <- rbind(sol.with.rf, tmp)
}
}

# tangency portfolio
w.tangent <- matrix(qp$solution / sum(qp$solution), ncol=1)
names(w.tangent) <- tickers
sigma.tangent <- sqrt(t(w.tangent) %*% Sigma %*% w.tangent)

colnames(sol.with.rf) <- c("mu", "stdev", "Sharpe", tickers)
```

```{r, echo=FALSE, fig.height=6}
plot(sol[,"stdev"], sol[,"mu"], type='l', col='red', lwd=2, xlab=expression(sigma), ylab=expression(mu),
     ylim=c(0, 0.40), xlim=c(.0, 0.40), bty='n', cex.lab=1.5)
lines(sol.with.rf[,"stdev"], sol.with.rf[,"mu"], type='l', col='green', lwd=2)
for(i in seq_along(tickers)) {
  text(sqrt(Sigma[i,i]), mu[i], tickers[i], cex=1.2, col="blue")
}
```
## Calcul de la Frontière (Long/Short)

```{r, echo=FALSE}
mu <- colMeans(daily.ret)*252
sigma <- cov(daily.ret)*252
tickers <- c("AAPL", "AMZN", "MSFT", "F", "SPY", "QQQ", "XOM", "MMM", "HD", "PG", "KO")
n <- length(mu)
min.ret = 0.05
mu.star <- seq(from=min.ret+abs(min(mu))/100, to=2*max(mu)-abs(max(mu))/100, length.out=100)
mu.free <- 0.03

sol <- NULL
for(mu.s in mu.star) {
  
# constraints: 2 equality
A.sum <- matrix(rep(1,n, ncol=1))
A.mat <- cbind(A.sum, matrix(mu))
b <- c(1, mu.s)
qp <- solve.QP(2*sigma, rep(0,n), A.mat, b, meq=2)
sharpe <- (mu.s - mu.free) / sqrt(qp$value)
  tmp <- matrix(c(mu.s, sqrt(qp$value), sharpe, qp$solution), nrow=1)

if(is.null(sol)) {
  sol <- tmp  
} else {
  sol <- rbind(sol, tmp)
}
}

colnames(sol) <- c("mu", "stdev", "Sharpe", tickers)
```

```{r, echo=FALSE, fig.height=6}
plot(sol[,"stdev"], sol[,"mu"], type='l', col='red', lwd=2, xlab=expression(sigma), ylab=expression(mu),
     ylim=c(0, 0.40), xlim=c(.0, 0.40), bty='n', cex.lab=1.5)

for(i in seq_along(tickers)) {
  text(sqrt(sigma[i,i]), mu[i], tickers[i], cex=1.2, col="blue")
}
```

## Allocation en fonction du risque

```{r, echo=FALSE, fig.height=6}
chart.StackedBar(sol[, 3+seq_along(mu)], xaxis.labels=round(sol[,2],2), 
                 xlab="SD Portefeuille", ylab="Allocation")
```

## Ajout d'un actif sans risque

```{r, tangent-long}

mu.star.v  <- seq(from=mu.free, to=0.35, length.out=30)
n <- length(mu)

optim.with.rf <- function(mu.star) {
  A.sum <- matrix(mu-mu.free, ncol=1)
A.mat <- cbind(A.sum, 
               rep(1, n),
               diag(n))
b <- c(mu.star-mu.free, 1, rep(0, n))
solve.QP(2*sigma, rep(0,n), A.mat, b, meq=2)
}

sol.with.rf <- NULL
for(mu.star in mu.star.v) {
  qp <- optim.with.rf(mu.star)

  sharpe <- (mu.star - mu.free) / sqrt(qp$value)
  tmp <- matrix(c(mu.star, sqrt(qp$value), sharpe, qp$solution), nrow=1)

if(is.null(sol.with.rf)) {
  sol.with.rf <- tmp  
} else {
  sol.with.rf <- rbind(sol.with.rf, tmp)
}
}

# tangency portfolio
w.tangent <- matrix(qp$solution / sum(qp$solution), ncol=1)
names(w.tangent) <- tickers
sigma.tangent <- sqrt(t(w.tangent) %*% sigma %*% w.tangent)

colnames(sol.with.rf) <- c("mu", "stdev", "Sharpe", tickers)
```

```{r, echo=FALSE, fig.height=6}
plot(sol[,"stdev"], sol[,"mu"], type='l', col='red', lwd=2, xlab=expression(sigma), ylab=expression(mu),
     ylim=c(0, 0.40), xlim=c(.0, 0.40), bty='n', cex.lab=1.5)
lines(sol.with.rf[,"stdev"], sol.with.rf[,"mu"], type='l', col='green', lwd=2)
for(i in seq_along(tickers)) {
  text(sqrt(sigma[i,i]), mu[i], tickers[i], cex=1.2, col="blue")
}
```